apiVersion: v1
data:
  admin.enabled: "true"
  application.instanceLabelKey: argocd.argoproj.io/instance
  application.resourceTrackingMethod: annotation+label
  application.sync.impersonation.enabled: "false"
  dex.config: |
    connectors:
    - type: oidc
      id: keycloak
      name: seigra.net
      config:
        issuer: https://auth.seigra.net/realms/home
        clientID: argocd
        clientSecret: $argocd-oidc-secret:client_secret
        scopes:
        - openid
        - profile
        - email
        getUserInfo: true
        userNameKey: preferred_username
        insecureEnableGroups: true
  exec.enabled: "false"
  kustomize.buildOptions: --enable-helm
  resource.compareoptions: |
    ignoreResourceStatusField: all
  resource.customizations: |
    argoproj.io/Application:
      health.lua: |
        hs = {}
        hs.status = "Progressing"
        hs.message = ""
        if obj.status ~= nil then
          if obj.status.health ~= nil then
            hs.status = obj.status.health.status
            if obj.status.health.message ~= nil then
              hs.message = obj.status.health.message
            end
          end
        end
        return hs
    "k8s.keycloak.org/Keycloak":
      health.lua: |
        local hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            local ready = false
            local haserrors = false
            local rollingupdate = false
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" then
                ready = condition.status == "True"
                ready_message = condition.message
              elseif condition.type == "HasErrors" then
                haserrors = condition.status == "True"
                haserrors_message = condition.message
              elseif condition.type == "RollingUpdate" then
                rollingupdate = condition.status == "True"
                rollingupdate_message = condition.message
              end
            end
            if ready and haserrors == false and rollingupdate == false then
              hs.status = "Healthy"
              hs.message = ready_message
            elseif rollingupdate == true then
              hs.status = "Progressing"
              hs.message = rollingupdate_message
            elseif ready == false and haserrors == false then
              hs.status = "Progressing"
              hs.message = "Waiting for resource to be available"
            else
              hs.status = "Degraded"
              hs.message = haserrors_message
            end
            return hs
          end
        end

        hs.status = "Progressing"
        hs.message = "Waiting for resource to be created"
        return hs
    "postgresql.cnpg.io/Cluster":
      health.lua: |
        local hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            local ready = false
            local continuousarchiving = false
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" then
                ready = condition.status == "True"
                ready_message = condition.message
              elseif condition.type == "ContinuousArchiving" then
                continuousarchiving = condition.status == "True"
                continuousarchiving_message = condition.message
              end
            end
            if ready and continuousarchiving then
              hs.status = "Healthy"
              hs.message = ready_message
            else
              hs.status = "Progressing"
              hs.message = ready_message
            end
            return hs
          end
        end

        hs.status = "Progressing"
        hs.message = "Waiting for resource to be created"
        return hs
    "*.upbound.io/*":
      health.lua: |
        health_status = {
          status = "Progressing",
          message = "Provisioning ..."
        }

        local function contains (table, val)
          for i, v in ipairs(table) do
            if v == val then
              return true
            end
          end
          return false
        end

        local has_no_status = {
          "ClusterProviderConfig",
          "ProviderConfig",
          "ProviderConfigUsage"
        }

        if obj.status == nil or next(obj.status) == nil and contains(has_no_status, obj.kind) then
          health_status.status = "Healthy"
          health_status.message = "Resource is up-to-date."
          return health_status
        end

        if obj.status == nil or next(obj.status) == nil or obj.status.conditions == nil then
          if (obj.kind == "ProviderConfig" or obj.kind == "ClusterProviderConfig") and obj.status.users ~= nil then
            health_status.status = "Healthy"
            health_status.message = "Resource is in use."
            return health_status
          end
          return health_status
        end

        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "LastAsyncOperation" then
            if condition.status == "False" then
              health_status.status = "Degraded"
              health_status.message = condition.message
              return health_status
            end
          end

          if condition.type == "Synced" then
            if condition.status == "False" then
              health_status.status = "Degraded"
              health_status.message = condition.message
              return health_status
            end
          end

          if condition.type == "Ready" then
            if condition.status == "True" then
              health_status.status = "Healthy"
              health_status.message = "Resource is up-to-date."
            end
          end
        end

        return health_status

    "*.crossplane.io/*":
      health.lua: |
        health_status = {
          status = "Progressing",
          message = "Provisioning ..."
        }

        local function contains (table, val)
          for i, v in ipairs(table) do
            if v == val then
              return true
            end
          end
          return false
        end

        local has_no_status = {
          "Composition",
          "CompositionRevision",
          "DeploymentRuntimeConfig",
          "ClusterProviderConfig",
          "ProviderConfig",
          "ProviderConfigUsage"
        }
        if obj.status == nil or next(obj.status) == nil and contains(has_no_status, obj.kind) then
            health_status.status = "Healthy"
            health_status.message = "Resource is up-to-date."
          return health_status
        end

        if obj.status == nil or next(obj.status) == nil or obj.status.conditions == nil then
          if (obj.kind == "ProviderConfig" or obj.kind == "ClusterProviderConfig") and obj.status.users ~= nil then
            health_status.status = "Healthy"
            health_status.message = "Resource is in use."
            return health_status
          end
          return health_status
        end

        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "LastAsyncOperation" then
            if condition.status == "False" then
              health_status.status = "Degraded"
              health_status.message = condition.message
              return health_status
            end
          end

          if condition.type == "Synced" then
            if condition.status == "False" then
              health_status.status = "Degraded"
              health_status.message = condition.message
              return health_status
            end
          end

          if contains({"Ready", "Healthy", "Offered", "Established", "ValidPipeline", "RevisionHealthy"}, condition.type) then
            if condition.status == "True" then
              health_status.status = "Healthy"
              health_status.message = "Resource is up-to-date."
            end
          end
        end

        return health_status
  resource.customizations.ignoreResourceUpdates.ConfigMap: |
    jqPathExpressions:
      # Ignore the cluster-autoscaler status
      - '.metadata.annotations."cluster-autoscaler.kubernetes.io/last-updated"'
      # Ignore the annotation of the legacy Leases election
      - '.metadata.annotations."control-plane.alpha.kubernetes.io/leader"'
  resource.customizations.ignoreResourceUpdates.Endpoints: |
    jsonPointers:
      - /metadata
      - /subsets
  resource.customizations.ignoreResourceUpdates.all: |
    jsonPointers:
    - /status
    - /metadata/resourceVersion
  resource.customizations.ignoreResourceUpdates.apps_ReplicaSet: |
    jqPathExpressions:
      - '.metadata.annotations."deployment.kubernetes.io/desired-replicas"'
      - '.metadata.annotations."deployment.kubernetes.io/max-replicas"'
      - '.metadata.annotations."rollout.argoproj.io/desired-replicas"'
  resource.customizations.ignoreResourceUpdates.argoproj.io_Application: |
    jqPathExpressions:
      - '.metadata.annotations."notified.notifications.argoproj.io"'
      - '.metadata.annotations."argocd.argoproj.io/refresh"'
      - '.metadata.annotations."argocd.argoproj.io/hydrate"'
      - '.operation'
  resource.customizations.ignoreResourceUpdates.argoproj.io_Rollout: |
    jqPathExpressions:
      - '.metadata.annotations."notified.notifications.argoproj.io"'
  resource.customizations.ignoreResourceUpdates.autoscaling_HorizontalPodAutoscaler: |
    jqPathExpressions:
      - '.metadata.annotations."autoscaling.alpha.kubernetes.io/behavior"'
      - '.metadata.annotations."autoscaling.alpha.kubernetes.io/conditions"'
      - '.metadata.annotations."autoscaling.alpha.kubernetes.io/metrics"'
      - '.metadata.annotations."autoscaling.alpha.kubernetes.io/current-metrics"'
  resource.customizations.ignoreResourceUpdates.discovery.k8s.io_EndpointSlice: |
    jsonPointers:
      - /metadata
      - /endpoints
      - /ports
  resource.exclusions: |
    - apiGroups:
        - cilium.io
      kinds:
        - CiliumIdentity
      clusters:
        - "*"
  resource.ignoreResourceUpdatesEnabled: "true"
  server.rbac.log.enforce.enable: "false"
  statusbadge.enabled: "false"
  timeout.hard.reconciliation: 0s
  timeout.reconciliation: 180s
  timeout.reconciliation.jitter: 1m
  url: https://argocd.seigra.net
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: server
    app.kubernetes.io/instance: argocd
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-cm
  namespace: argocd
